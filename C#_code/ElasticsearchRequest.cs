using Elasticsearch.Net;
using Nest;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
namespace CentralStation.Components.Elasticsearch
{
    public class Sku
    {
        public class TextLang
        {
            public string? Fr { get; set; }
            public string? En { get; set; }
            public string? Es { get; set; }
            public string? Ge { get; set; }
        }
        public string? SkuGuid { get; set; }
        public TextLang? SkuDescription { get; set; }
        public TextLang? SkuName { get; set; }
        public double[]? Embedding { get; set; }

        private static readonly string[] frStopwords = Utils.ImportJsonFile<string[]>("Resources/stopwords-fr.json");
        private static readonly AsciiTranslation[] asciiTranslations = Utils.ImportJsonFile<AsciiTranslation[]>("Resources/asciiTranslations.json");

        private static string TextCleaner(string text, string langue)
        {
            Regex tagRegex = new Regex("<[^>]*>");
            Regex largeSpaceRegex = new Regex(" {2,}"); // To remove spaces generated by tag removal
            Regex regexPromos = new Regex(@"(\* Offre de bienvenue 5% de réduction sur votre 1ère commande avec le code: PROMO5)|(- Offre -5%)|(A partir [0-9]+ € D'ACHAT = [0-9]+% DE REMISE-code promo OFFRE[0-9]+)|(Offre de Bienvenue : 5% avec le code promo : PROMO5)|(DERNIÈRE DEMARQUE -10% SUPPLEMENTAIRES.*AVEC LE CODE PROMO : 10)");
            Regex regexDimensions = new Regex("[0-9]+ ?x ?[0-9]+( cm)?");
            Regex elisionRegex = new Regex("(l|d|m|t|s|j)('|\u2019)"); // u2019 : ’
            Regex specialCharRegex = new Regex("\\W+");
            Regex numbersRegex = new Regex("[0-9]+");

            // Global replacements
            text = tagRegex.Replace(text, " "); // Replace tags with a space to avoid merging words
            text = largeSpaceRegex.Replace(text, " "); // Some adjacent tags generate multiple spaces

            //if (langue == "Fr")
            //{
            //    text = regexPromos.Replace(text, "");
            //    text = regexDimensions.Replace(text, "");
            //}

            //text = text.ToLower();

            // Convert all letters to ASCII
            foreach (var change in asciiTranslations)
            {
                text = Regex.Replace(text, change.Letters, change.Base);
            }
            //text = numbersRegex.Replace(text, "");

            // Token processing
            //var tokens = text.Split(" ")
            //    .Select(token =>
            //    {
            //        if (langue == "Fr") token = elisionRegex.Replace(token, "");
            //        token = specialCharRegex.Replace(token, "");
            //        if (langue == "Fr" && frStopwords.Contains(token)) return null;
            //        return token;
            //    })
            //.Where(token => !(token == null || token == ""))
            //.Distinct() // Remove duplicates
            //.ToArray();

            //return string.Join(" ", tokens);
            return text;
        }

        public void SkuCleaning()
        {
            if (this.SkuDescription != null)
            {
                foreach (PropertyInfo lang in this.SkuDescription.GetType().GetProperties())
                {
                    string? text = (string?)lang.GetValue(this.SkuDescription);
                    if (text != null)
                    {
                        lang.SetValue(this.SkuDescription, TextCleaner(text, lang.Name));
                    }
                }
            }

            if (this.SkuName != null)
            {
                foreach (PropertyInfo lang in this.SkuName.GetType().GetProperties())
                {
                    string? text = (string?)lang.GetValue(this.SkuName);
                    if (text != null)
                    {
                        lang.SetValue(this.SkuName, TextCleaner(text, lang.Name));
                    }
                }
            }
        }


        /**
         * Tries to combine two embeddings into one. Handles null values.
         */
        public static double[]? CombineEmbeddings(double[]? emb1, double[]? emb2, int emb1Weight, int emb2Weight)
        {
            double[]? CombinedEmbedding;
            if (emb1 != null && emb2 != null)
            {
                double[] fusion = Utils.CombineVectors(emb1, emb2, emb2Weight, emb1Weight);
                double[] normalizedEmbeddings = Utils.NormalizeEmbedding(fusion);
                CombinedEmbedding = normalizedEmbeddings;
            }
            else if (emb1 != null)
            {
                CombinedEmbedding = emb1;
            }
            else if (emb2 != null)
            {
                CombinedEmbedding = emb2;
            }
            else
            {
                CombinedEmbedding = null;
            }

            return CombinedEmbedding;
        }

        private class AsciiTranslation
        {
            public string Base { get; set; }
            public string Letters { get; set; }
        }

        public static Sku[] generateSkus(int size, int dimensions, bool sizeInMb = true)
        {
            if (sizeInMb && dimensions != 179) throw new ArgumentException("[generateSkus] dimensions must be 179 to match the size number in mb");

            int nbSkus = sizeInMb ? 250 * size : size;
            Sku[] generatedSkus = new Sku[nbSkus];
            for (int i = 0; i < nbSkus; i++)
            {
                string text = "Coucou ceci est un test pour remplir au MAXIMUM les produits et avoir un max de gb";
                var langTexts = new Sku.TextLang()
                {
                    Fr = text,
                    En = text,
                    Es = text,
                    Ge = text
                };
                generatedSkus[i] = new Sku()
                {
                    Embedding = Enumerable.Repeat(0.0917248994283938d, 179).ToArray(),
                    SkuName = langTexts,
                    SkuDescription = langTexts,
                    SkuGuid = "coucou ça va?"
                };
            }

            return generatedSkus;
        }
    }

    // TODO : deplacer dans le bon fichier
    public class Utils
    {
        public static T ImportJsonFile<T>(string path)
        {
            try
            {
                var file = File.ReadAllText(path);
                var convertedFile = JsonConvert.DeserializeObject<T>(file);

                if (convertedFile == null) throw new JsonException();
                return convertedFile;
            }
            catch (JsonException e)
            {
                throw new JsonException("File " + path + " json conversion failed", e);
            }
        }
        public static double[] CombineVectors(double[] v1, double[] v2, double v1Weight, double v2Weight)
        {
            int vectorsNumber = v1.Length;
            double[] combinedVectors = new double[vectorsNumber];
            for (int i = 0; i < vectorsNumber; i++)
            {
                combinedVectors[i] = ((v1Weight * v1[i] + v2Weight * v2[i]) / (v1Weight + v2Weight));
            }
            return combinedVectors;
        }

        public static double[] NormalizeEmbedding(double[] embedding)
        {
            if (embedding == null || embedding.Length == 0) throw new ArgumentException("[normalizeEmbedding] embedding is null or empty");
            double vectorNorm = Math.Sqrt(embedding.Sum(x => x * x));
            return embedding.Select(dimension => dimension / vectorNorm).ToArray();
        }

        public static T[] getBatch<T>(in T[] elements, int iBatch, int batchSize)
        {
            int batchNumber = elements.Length / batchSize + 1;
            bool isLastBatch = iBatch == batchNumber - 1;
            int start = iBatch * batchSize;
            int end = isLastBatch ? elements.Length : (iBatch + 1) * batchSize;

            return elements[start..end];
        }
    }


    public class ElasticsearchRequest
    {
        private readonly bool __debug__;
        private readonly string indexName;
        private readonly int maxBulkLengthMb;
        private readonly ElasticClient elastic;

        public ElasticsearchRequest(string username, string password, string elasticPath, string indexName, bool debugMode, int maxBulkLengthMb)
        {
            var settings = new ConnectionSettings(new Uri(elasticPath))
                .DefaultIndex(indexName)
                .ServerCertificateValidationCallback((sender, certificate, chain, sslPolicyErrors) => true)     // @warning a retirer en prod : il faut gerer le certificat
                .BasicAuthentication(username, password)
                .ThrowExceptions()
                .SniffOnStartup();

            if (debugMode) settings.EnableDebugMode();
            this.__debug__ = debugMode;
            this.indexName = indexName;
            this.maxBulkLengthMb = maxBulkLengthMb - 4;// 4Mb pour la marge de securite (notament pour la difference entre le poids de chaque sku additionné et du total final)
            this.elastic = new ElasticClient(settings);
        }

        public void CreateIndex(int embedding_dims)
        {
            // Suppression ancien index
            var deleteRes = elastic.Indices.Delete(new DeleteIndexRequest(indexName)
            {
                IgnoreUnavailable = true
            });


            // Creation
            var createRes = elastic.Indices.Create(indexName, c => c
                .Map<Sku>(m => m
                    .Properties(ps => ps
                        .Text(t => t
                            .Name(n => n.SkuGuid))
                        .Object<Sku.TextLang>(o => o
                            .Name(n => n.SkuDescription)
                            .Properties(ips => ips
                                .Text(t => t.Name("fr").Analyzer("french"))
                                .Text(t => t.Name("en").Analyzer("english"))
                                .Text(t => t.Name("es").Analyzer("spanish"))
                                .Text(t => t.Name("ge").Analyzer("german"))
                            )
                        )
                        .Object<Sku.TextLang>(o => o
                            .Name(n => n.SkuName)
                            .Properties(ips => ips
                                .Text(t => t.Name("fr").Analyzer("french"))
                                .Text(t => t.Name("en").Analyzer("english"))
                                .Text(t => t.Name("es").Analyzer("spanish"))
                                .Text(t => t.Name("ge").Analyzer("german"))
                            )
                        )
                        .DenseVector(dv => dv
                            .Name(n => n.Embedding)
                            .Dimensions(embedding_dims)
                        )
                    )
                )
            );
        }


        public void BulkIndexingApi(in Sku[] skus)
        {
            if (skus.Length == 0) throw new Exception("No sku to index");

            double maxBytes = maxBulkLengthMb * 1024 * 1024;

            List<Sku> batch = new();
            int batchSize = 0;  // Attention, la taille du json final ne fait pas exactement la taille de la somme de ses objets

            for (int i = 0; i < skus.Length; i++)
            {
                Sku sku = skus[i];
                int skuBytes = Encoding.UTF8.GetByteCount(JsonConvert.SerializeObject(sku));

                // Vidage du batch si trop gros
                if (batchSize + skuBytes > maxBytes)
                {
                    if (skuBytes > maxBytes)
                    {
                        // Cas exceptionnel : sku trop gros pour le batch
                        throw new HttpPayloadTooLargeException("Sku " + sku.SkuGuid + " is too big to be indexed in bulk");
                    }

                    BulkIndexingApiBatch(batch.ToArray());
                    if (__debug__) Console.WriteLine($"   {batch.Count} produits enregistres en bdd (" + (batchSize / 1024 / 1024 * 10) / 10d + "Mb)");

                    batch.Clear();
                    batchSize = 0;
                }

                // Ajout du sku au batch
                batch.Add(sku);
                batchSize += skuBytes;
            }

            // Envoi du dernier batch
            BulkIndexingApiBatch(batch.ToArray());
            if (__debug__) Console.WriteLine($"   {batch.Count} produits enregistres en bdd (" + (batchSize / 1024 / 1024 * 10) / 10d + "Mb)");
        }

        public void BulkIndexingApiBatch(in Sku[] skus)
        {
            if (skus.Length == 0) throw new Exception("No sku to index");
            var req = new BulkDescriptor().Index(indexName).IndexMany(skus);
            if (__debug__) req.Refresh(Refresh.True);

            var response = elastic.Bulk(req);

            if (response.Errors)
            {
                var firstErrorItem = response.ItemsWithErrors.ToList()[0];
                throw new Exception("Error during indexing : " + response.ItemsWithErrors.Count() + " skus had problems.\n" + firstErrorItem?.Error?.Reason);
            }
        }

        public async Task<string[]> RequestAiSearch(string input, int eMBEDDING_DIMS)
        {
            throw new NotImplementedException();
        }

        public string[] RequestFulltextSearch(string input, int eMBEDDING_DIMS)
        {
            throw new NotImplementedException();
        }

        public class HttpPayloadTooLargeException : Exception
        {
            public HttpPayloadTooLargeException(string message)
                : base(message)
            {
            }
        }
    }
}
